{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"metasploit/","text":"auxiliary/server/openssl_altchainsforgery_mitm_proxy This module exploits a logic error in OpenSSL by impersonating the server and sending a specially-crafted chain of certificates, resulting in certain checks on untrusted certificates to be bypassed on the client, allowing it to use a valid leaf certificate as a CA certificate to sign a fake certificate. The SSL/TLS session is then proxied to the server allowing the session to continue normally and application data transmitted between the peers to be saved. The valid leaf certificate must not contain the keyUsage extension or it must have at least the keyCertSign bit set (see X509_check_issued function in crypto/x509v3/v3_purp.c); otherwise; X509_verify_cert fails with X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY. This module requires an active man-in-the-middle attack. auxiliary/server/jsse_skiptls_mitm_proxy This module exploits an incomplete internal state distinction in Java Secure Socket Extension (JSSE) by impersonating the server and finishing the handshake before the peers have authenticated themselves and instantiated negotiated security parameters, resulting in a plaintext SSL/TLS session with the client. This plaintext SSL/TLS session is then proxied to the server using a second SSL/TLS session from the proxy to the server (or an alternate fake server) allowing the session to continue normally and plaintext application data transmitted between the peers to be saved. This module requires an active man-in-the-middle attack. auxiliary/server/dhclient_bash_env This module exploits the Shellshock vulnerability, a flaw in how the Bash shell handles external environment variables. This module targets dhclient by responding to DHCP requests with a malicious hostname, domainname, and URL which are then passed to the configuration scripts as environment variables, resulting in code execution. auxiliary/admin/http/katello_satellite_priv_esc This module exploits a missing authorization vulnerability in the \"update_roles\" action of \"users\" controller of Katello and Red Hat Satellite (Katello 1.5.0-14 and earlier) by changing the specified account to an administrator account. exploit/linux/http/cfme_manageiq_evm_upload_exec This module exploits a path traversal vulnerability in the \"linuxpkgs\" action of \"agent\" controller of the Red Hat CloudForms Management Engine 5.1 (ManageIQ Enterprise Virtualization Manager 5.0 and earlier). It uploads a fake controller to the controllers directory of the Rails application with the encoded payload as an action and sends a request to this action to execute the payload. Optionally, it can also upload a routing file containing a route to the action. (Which is not necessary, since the application already contains a general default route.) auxiliary/admin/http/cfme_manageiq_evm_pass_reset This module exploits a SQL injection vulnerability in the \"explorer\" action of \"miq_policy\" controller of the Red Hat CloudForms Management Engine 5.1 (ManageIQ Enterprise Virtualization Manager 5.0 and earlier) by changing the password of the target account to the specified password. auxiliary/admin/http/foreman_openstack_satellite_priv_esc This module exploits a mass assignment vulnerability in the 'create' action of 'users' controller of Foreman and Red Hat OpenStack/Satellite (Foreman 1.2.0-RC1 and earlier) by creating an arbitrary administrator account. For this exploit to work, your account must have 'create_users' permission (e.g., Manager role). exploit/linux/http/foreman_openstack_satellite_code_exec This module exploits a code injection vulnerability in the 'create' action of 'bookmarks' controller of Foreman and Red Hat OpenStack/Satellite (Foreman 1.2.0-RC1 and earlier). auxiliary/scanner/snmp/aix_version AIX SNMP Scanner Auxiliary Module exploit/aix/rpc_ttdbserverd_realpath This module exploits a buffer overflow vulnerability in _tt_internal_realpath function of the ToolTalk database server (rpc.ttdbserverd). payload/aix/ppc/shell_reverse_tcp Connect back to attacker and spawn a command shell payload/aix/ppc/shell_find_port Spawn a shell on an established connection payload/aix/ppc/shell_bind_tcp Listen for a connection and spawn a command shell payload/linux/ppc64/shell_reverse_tcp Connect back to attacker and spawn a command shell payload/linux/ppc64/shell_find_port Spawn a shell on an established connection payload/linux/ppc64/shell_bind_tcp Listen for a connection and spawn a command shell payload/linux/ppc/shell_reverse_tcp Connect back to attacker and spawn a command shell payload/linux/ppc/shell_find_port Spawn a shell on an established connection payload/linux/ppc/shell_bind_tcp Listen for a connection and spawn a command shell exploit/linux/samba/lsa_transnames_heap This module triggers a heap overflow in the LSA RPC service of the Samba daemon. This module uses the TALLOC chunk overwrite method (credit Ramon and Adriano), which only works with Samba versions 3.0.21-3.0.24. Additionally, this module will not work when the Samba \"log level\" parameter is higher than \"2\". payload/linux/x86/shell_reverse_tcp Connect back to attacker and spawn a command shell payload/linux/x86/shell_find_port Spawn a shell on an established connection exploit/solaris/sunrpc/sadmind_adm_build_path This module exploits a buffer overflow vulnerability in adm_build_path() function of sadmind daemon. The distributed system administration daemon (sadmind) is the daemon used by Solstice AdminSuite applications to perform distributed system administration operations. The sadmind daemon is started automatically by the inetd daemon whenever a request to invoke an operation is received. The sadmind daemon process continues to run for 15 minutes after the last request is completed, unless a different idle-time is specified with the -i command line option. The sadmind daemon may be started independently from the command line, for example, at system boot time. In this case, the -i option has no effect; sadmind continues to run, even if there are no active requests. auxiliary/scanner/misc/ib_service_mgr_info This module retrieves version of the services manager, version and implementation of the InterBase server from InterBase Services Manager. exploit/windows/misc/ib_svc_attach This module exploits a stack buffer overflow in Borland InterBase by sending a specially crafted service attach request. exploit/windows/misc/ib_isc_create_database This module exploits a stack buffer overflow in Borland InterBase by sending a specially crafted create request. exploit/windows/misc/ib_isc_attach_database This module exploits a stack buffer overflow in Borland InterBase by sending a specially crafted attach request. exploit/windows/misc/fb_svc_attach This module exploits a stack buffer overflow in Borland InterBase by sending a specially crafted service attach request. exploit/windows/misc/fb_isc_create_database This module exploits a stack buffer overflow in Borland InterBase by sending a specially crafted create request. exploit/windows/misc/fb_isc_attach_database This module exploits a stack buffer overflow in Borland InterBase by sending a specially crafted create request. exploit/linux/misc/ib_pwd_db_aliased This module exploits a stack buffer overflow in Borland InterBase by sending a specially crafted attach request. exploit/linux/misc/ib_open_marker_file This module exploits a stack buffer overflow in Borland InterBase by sending a specially crafted attach request. exploit/linux/misc/ib_jrd8_create_database This module exploits a stack buffer overflow in Borland InterBase by sending a specially crafted create request. exploit/linux/misc/ib_inet_connect This module exploits a stack buffer overflow in Borland InterBase by sending a specially crafted service attach request. payload/linux/x86/shell_bind_tcp Listen for a connection and spawn a command shell payload/bsd/x86/shell_reverse_tcp Connect back to attacker and spawn a command shell payload/bsd/x86/shell_find_port Spawn a shell on an established connection payload/bsd/x86/shell_bind_tcp Listen for a connection and spawn a command shell exploit/solaris/samba/lsa_transnames_heap This module triggers a heap overflow in the LSA RPC service of the Samba daemon. This module uses the TALLOC chunk overwrite method (credit Ramon and Adriano), which only works with Samba versions 3.0.21-3.0.24. Additionally, this module will not work when the Samba \"log level\" parameter is higher than \"2\". payload/solaris/x86/shell_reverse_tcp Connect back to attacker and spawn a command shell payload/solaris/x86/shell_find_port Spawn a shell on an established connection payload/solaris/x86/shell_bind_tcp Listen for a connection and spawn a command shell payload/osx/x86/shell_reverse_tcp Connect back to attacker and spawn a command shell payload/osx/x86/shell_find_port Spawn a shell on an established connection exploit/osx/samba/lsa_transnames_heap This module triggers a heap overflow in the LSA RPC service of the Samba daemon. This module uses the szone_free() to overwrite the size() or free() pointer in initial_malloc_zones structure. payload/osx/x86/shell_bind_tcp Listen for a connection and spawn a command shell","title":"Metasploit"},{"location":"vulnerabilities/","text":"CVE-2013-2143 The users controller in Katello 1.5.0-14 and earlier, and Red Hat Satellite, does not check authorization for the update_roles action, which allows remote authenticated users to gain privileges by setting a user account to an administrator account. CVE-2013-2121 Eval injection vulnerability in the create method in the Bookmarks controller in Foreman before 1.2.0-RC2 allows remote authenticated users with permissions to create bookmarks to execute arbitrary code via a controller name attribute. CVE-2013-2113 The create method in app/controllers/users_controller.rb in Foreman before 1.2.0-RC2 allows remote authenticated users with permissions to create or edit other users to gain privileges by (1) changing the admin flag or (2) assigning an arbitrary role. CVE-2013-2068 Multiple directory traversal vulnerabilities in the AgentController in Red Hat CloudForms Management Engine 2.0 allow remote attackers to create and overwrite arbitrary files via a .. (dot dot) in the filename parameter to the (1) log, (2) upload, or (3) linuxpkgs method. CVE-2013-2050 SQL injection vulnerability in the miq_policy controller in Red Hat CloudForms 2.0 Management Engine (CFME) 5.1 and ManageIQ Enterprise Virtualization Manager 5.0 and earlier allows remote authenticated users to execute arbitrary SQL commands via the profile[] parameter in an explorer action. CVE-2013-2049 Red Hat CloudForms 2 Management Engine (CFME) allows remote attackers to conduct session tampering attacks by leveraging use of a static secret_token.rb secret. CVE-2012-0815 The headerVerifyInfo function in lib/header.c in RPM before 4.9.1.3 allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a negative value in a region offset of a package header, which is not properly handled in a numeric range comparison. CVE-2012-0061 The headerLoad function in lib/header.c in RPM before 4.9.1.3 does not properly validate region tags, which allows user-assisted remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large region size in a package header. CVE-2012-0060 RPM before 4.9.1.3 does not properly validate region tags, which allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via an invalid region tag in a package header to the (1) headerLoad, (2) rpmReadSignature, or (3) headerVerify function. CVE-2010-0415 The do_pages_move function in mm/migrate.c in the Linux kernel before 2.6.33-rc7 does not validate node values, which allows local users to read arbitrary kernel memory locations, cause a denial of service (OOPS), and possibly have unspecified other impact by specifying a node that is not part of the kernel's node set. CVE-2009-2727 Stack-based buffer overflow in the _tt_internal_realpath function in the ToolTalk library (libtt.a) in IBM AIX 5.2.0, 5.3.0, 5.3.7 through 5.3.10, and 6.1.0 through 6.1.3, when the rpc.ttdbserver daemon is enabled in /etc/inetd.conf, allows remote attackers to execute arbitrary code via a long XDR-encoded ASCII string to remote procedure 15. CVE-2009-2407 Heap-based buffer overflow in the parse_tag_3_packet function in fs/ecryptfs/keystore.c in the eCryptfs subsystem in the Linux kernel before 2.6.30.4 allows local users to cause a denial of service (system crash) or possibly gain privileges via vectors involving a crafted eCryptfs file, related to a large encrypted key size in a Tag 3 packet. CVE-2009-2406 Stack-based buffer overflow in the parse_tag_11_packet function in fs/ecryptfs/keystore.c in the eCryptfs subsystem in the Linux kernel before 2.6.30.4 allows local users to cause a denial of service (system crash) or possibly gain privileges via vectors involving a crafted eCryptfs file, related to not ensuring that the key signature length in a Tag 11 packet is compatible with the key signature buffer size. CVE-2008-4556 Stack-based buffer overflow in the adm_build_path function in sadmind in Sun Solstice AdminSuite on Solaris 8 and 9 allows remote attackers to execute arbitrary code via a crafted request. CVE-2007-5246 Multiple stack-based buffer overflows in Firebird LI 2.0.0.12748 and 2.0.1.12855, and WI 2.0.0.12748 and 2.0.1.12855, allow remote attackers to execute arbitrary code via (1) a long attach request on TCP port 3050 to the isc_attach_database function or (2) a long create request on TCP port 3050 to the isc_create_database function. CVE-2007-5245 Multiple stack-based buffer overflows in Firebird LI 1.5.3.4870 and 1.5.4.4910, and WI 1.5.3.4870 and 1.5.4.4910, allow remote attackers to execute arbitrary code via (1) a long service attach request on TCP port 3050 to the SVC_attach function or (2) unspecified vectors involving the INET_connect function. CVE-2007-5244 Stack-based buffer overflow in Borland InterBase LI 8.0.0.53 through 8.1.0.253 on Linux, and possibly unspecified versions on Solaris, allows remote attackers to execute arbitrary code via a long attach request on TCP port 3050 to the open_marker_file function. CVE-2007-5243 Multiple stack-based buffer overflows in Borland InterBase LI 8.0.0.53 through 8.1.0.253, and WI 5.1.1.680 through 8.1.0.257, allow remote attackers to execute arbitrary code via (1) a long service attach request on TCP port 3050 to the (a) SVC_attach or (b) INET_connect function, (2) a long create request on TCP port 3050 to the (c) isc_create_database or (d) jrd8_create_database function, (3) a long attach request on TCP port 3050 to the (e) isc_attach_database or (f) PWD_db_aliased function, or unspecified vectors involving the (4) jrd8_attach_database or (5) expand_filename2 function. CVE-2007-4684 Integer overflow in the kernel in Apple Mac OS X 10.4 through 10.4.10 allows local users to execute arbitrary code via a large num_sels argument to the i386_set_ldt system call. CVE-2007-0430 The shared_region_map_file_np function in Apple Mac OS X 10.4.8 and earlier kernel allows local users to cause a denial of service (memory corruption) via a large mappingCount value. CVE-2006-4655 Buffer overflow in the Strcmp function in the XKEYBOARD extension in X Window System X11R6.4 and earlier, as used in SCO UnixWare 7.1.3 and Sun Solaris 8 through 10, allows local users to gain privileges via a long _XKB_CHARSET environment variable value. CVE-2006-4178 Integer signedness error in the i386_set_ldt call in FreeBSD 5.5, and possibly earlier versions down to 5.2, allows local users to cause a denial of service (crash) via unspecified arguments that use negative signed integers to cause the bzero function to be called with a large length parameter, a different vulnerability than CVE-2006-4172. CVE-2006-4172 Integer overflow vulnerability in the i386_set_ldt call in FreeBSD 5.5, and possibly earlier versions down to 5.2, allows local users to cause a denial of service (crash) and possibly execute arbitrary code via unspecified vectors, a different vulnerability than CVE-2006-4178.","title":"Vulnerabilities"},{"location":"posts/2020-09-16-rust-exploit-mitigations/","tags":["compiler","exploit mitigations","programming language","rust"],"text":"The contents of this post are now part of the official Rust documentation as part of the The rustc book . {: .lead} This post documents the exploit mitigations supported by the Rust compiler, and is by no means an extensive survey of the Rust programming language\u2019s security features. This post is for software engineers working with the Rust programming language, and assumes prior knowledge of the Rust programming language and its toolchain. Introduction The Rust programming language provides memory[1] and thread[2] safety guarantees via its ownership[3], references and borrowing[4], and slice types[5] features. However, Unsafe Rust[6] introduces unsafe blocks, unsafe functions and methods, unsafe traits, and new types that are not subject to the borrowing rules. Parts of the Rust standard library are implemented as safe abstractions over unsafe code (and historically have been vulnerable to memory corruption[7]). Furthermore, the Rust code and documentation encourage creating safe abstractions over unsafe code. This can cause a false sense of security if unsafe code is not properly reviewed and tested. Unsafe Rust introduces features that do not provide the same memory and thread safety guarantees. This causes programs or libraries to be susceptible to memory corruption (CWE-119)[8] and concurrency issues (CWE-557)[9]. Modern C and C++ compilers provide exploit mitigations to increase the difficulty to exploit vulnerabilities resulting from these issues. Therefore, the Rust compiler must also support these exploit mitigations in order to mitigate vulnerabilities resulting from the use of Unsafe Rust. This post documents these exploit mitigations and how they apply to Rust. This post does not discuss the effectiveness of these exploit mitigations as they vary greatly depending on several factors besides their design and implementation, but rather describe what they do, so their effectiveness can be understood within a given context. Exploit mitigations This section documents the exploit mitigations applicable to the Rust compiler when building programs for the Linux operating system on the AMD64 architecture and equivalent. 1 All examples in this section were built using the Rust compiler version 1.40.0 (2019-12-19) on Debian testing (Bullseye). The Rust Programming Language currently has no specification. The Rust compiler (i.e., rustc) is the language reference implementation. All references to \u201cthe Rust compiler\u201d in this post refer to the language reference implementation. Table I \\ Summary of exploit mitigations supported by the Rust compiler when building programs for the Linux operating system on the AMD64 architecture and equivalent. {: .table-title} Exploit mitigation Supported and enabled by default Since Position-independent executable Yes 0.12.0 (2014-10-09) Integer overflow checks Yes (enabled when debug assertions are enabled, and disabled when debug assertions are disabled) 1.1.0 (2015-06-25) Non-executable memory regions Yes 1.8.0 (2016-04-14) Stack clashing protection Yes 1.20.0 (2017-08-31) Read-only relocations and immediate binding Yes 1.21.0 (2017-10-12) Heap corruption protection Yes 1.32.0 (2019-01-17) (via operating system default or specified allocator) Stack smashing protection No Forward-edge control flow protection Yes Nightly Backward-edge control flow protection (e.g., shadow and safe stack) No 1. See https://github.com/rust-lang/rust/tree/master/compiler/rustc_target/src/spec for a list of targets and their default options. \u21a9 {: .fn #fn:1} Position-independent executable Position-independent executable increases the difficulty of the use of code reuse exploitation techniques, such as return-oriented programming (ROP) and variants, by generating position-independent code for the executable, and instructing the dynamic linker to load it similarly to a shared object at a random load address, thus also benefiting from address-space layout randomization (ASLR). This is also referred to as \u201cfull ASLR\u201d. The Rust compiler supports position-independent executable, and enables it by default since version 0.12.0 (2014-10-09)[10]\u2013[13]. $ readelf -h target/release/hello-rust | grep Type: Type: DYN (Shared object file) Fig. 1.\u2003Checking if an executable is a position-independent executable. {: .figure-caption} An executable with an object type of ET_DYN (i.e., shared object) and not ET_EXEC (i.e., executable) is a position-independent executable (see Fig. 1). Integer overflow checks Integer overflow checks protects programs from undefined and unintended behavior (which may cause vulnerabilities) by checking for results of signed and unsigned integer computations that cannot be represented in their type, resulting in an overflow or wraparound. The Rust compiler supports integer overflow checks, and enables it when debug assertions are enabled since version 1.0.0 (2015-05-15)[14]\u2013[17], but support for it was not completed until version 1.1.0 (2015-06-25)[16]. An option to control integer overflow checks was later stabilized in version 1.17.0 (2017-04-27)[18]\u2013[20]. fn main() { let u: u8 = 255; println!(\"u: {}\", u + 1); } Fig. 2.\u2003hello-rust-integer program. {: .figure-caption} $ cargo run Compiling hello-rust-integer v0.1.0 (/home/rcvalle/hello-rust-integer) Finished dev [unoptimized + debuginfo] target(s) in 0.23s Running `target/debug/hello-rust-integer` thread 'main' panicked at 'attempt to add with overflow', src/main.rs:3:23 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace. Fig. 3.\u2003Build and execution of hello-rust-integer with debug assertions enabled. {: .figure-caption} $ cargo run --release Compiling hello-rust-integer v0.1.0 (/home/rcvalle/hello-rust-integer) Finished release [optimized] target(s) in 0.23s Running `target/release/hello-rust-integer` u: 0 Fig. 4.\u2003Build and execution of hello-rust-integer with debug assertions disabled. {: .figure-caption} Integer overflow checks are enabled when debug assertions are enabled (see Fig. 3), and disabled when debug assertions are disabled (see Fig. 4). To enable integer overflow checks independently, use the option to control integer overflow checks, scoped attributes, or explicit checking methods such as checked_add 2 . It is recommended that explicit wrapping methods such as wrapping_add be used when wrapping semantics are intended, and that explicit checking and wrapping methods always be used when using Unsafe Rust. 2. See https://doc.rust-lang.org/std/primitive.u32.html for more information on the checked, overflowing, saturating, and wrapping methods (using u32 as an example). \u21a9 {: .fn #fn:2} Non-executable memory regions Non-executable memory regions increase the difficulty of exploitation by limiting the memory regions that can be used to execute arbitrary code. Most modern processors provide support for the operating system to mark memory regions as non executable, but it was previously emulated by software, such as in grsecurity/PaX's PAGEEXEC and SEGMEXEC , on processors that did not provide support for it. This is also known as \u201cNo Execute (NX) Bit\u201d, \u201cExecute Disable (XD) Bit\u201d, \u201cExecute Never (XN) Bit\u201d, and others. The Rust compiler supports non-executable memory regions, and enables it by default since its initial release, version 0.1 (2012-01-20)[21], [22], but has regressed since then[23]\u2013[25], and enforced by default since version 1.8.0 (2016-04-14)[25]. $ readelf -l target/release/hello-rust | grep -A 1 GNU_STACK GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 0x10 Fig. 5.\u2003Checking if non-executable memory regions are enabled for a given binary. {: .figure-caption} The presence of an element of type PT_GNU_STACK in the program header table with the PF_X (i.e., executable) flag unset indicates non-executable memory regions 3 are enabled for a given binary (see Fig. 5). Conversely, the presence of an element of type PT_GNU_STACK in the program header table with the PF_X flag set or the absence of an element of type PT_GNU_STACK in the program header table indicates non-executable memory regions are not enabled for a given binary. 3. See the Appendix section for more information on why it affects other memory regions besides the stack. \u21a9 {: .fn #fn:3} Stack clashing protection Stack clashing protection protects the stack from overlapping with another memory region\u2014allowing arbitrary data in both to be overwritten using each other\u2014by reading from the stack pages as the stack grows to cause a page fault when attempting to read from the guard page/region. This is also referred to as \u201cstack probes\u201d or \u201cstack probing\u201d. The Rust compiler supports stack clashing protection via stack probing, and enables it by default since version 1.20.0 (2017-08-31)[26]\u2013[29]. Fig. 6. Cross references to __rust_probestack in hello-rust. {: .figure-caption} fn hello() { println!(\"Hello, world!\"); } fn main() { let _: [u64; 1024] = [0; 1024]; hello(); } Fig 7. Modified hello-rust. {: .figure-caption} Fig. 8. Cross references to __rust_probestack in modified hello-rust. {: .figure-caption} To check if stack clashing protection is enabled for a given binary, search for cross references to __rust_probestack . The __rust_probestack is called in the prologue of functions whose stack size is larger than a page size (see Fig. 6), and can be forced for illustration purposes by modifying the hello-rust example as seen in Fig. 7 and Fig. 8. Read-only relocations and immediate binding Read-only relocations protect segments containing relocations and relocation information (i.e., .init_array , .fini_array , .dynamic , and .got ) from being overwritten by marking these segments read only. This is also referred to as \u201cpartial RELRO\u201d. The Rust compiler supports read-only relocations, and enables it by default since version 1.21.0 (2017-10-12)[30], [31]. $ readelf -l target/release/hello-rust | grep GNU_RELRO GNU_RELRO 0x000000000002ee00 0x000000000002fe00 0x000000000002fe00 Fig. 9.\u2003Checking if read-only relocations is enabled for a given binary. {: .figure-caption} The presence of an element of type PT_GNU_RELRO in the program header table indicates read-only relocations are enabled for a given binary (see Fig. 9). Conversely, the absence of an element of type PT_GNU_RELRO in the program header table indicates read-only relocations are not enabled for a given binary. Immediate binding protects additional segments containing relocations (i.e., .got.plt ) from being overwritten by instructing the dynamic linker to perform all relocations before transferring control to the program during startup, so all segments containing relocations can be marked read only (when combined with read-only relocations). This is also referred to as \u201cfull RELRO\u201d. The Rust compiler supports immediate binding, and enables it by default since version 1.21.0 (2017-10-12)[30], [31]. $ readelf -d target/release/hello-rust | grep BIND_NOW 0x000000000000001e (FLAGS) BIND_NOW Fig. 10.\u2003Checking if immediate binding is enabled for a given binary. {: .figure-caption} The presence of an element with the DT_BIND_NOW tag and the DF_BIND_NOW flag 4 in the dynamic section indicates immediate binding is enabled for a given binary (see Fig. 10). Conversely, the absence of an element with the DT_BIND_NOW tag and the DF_BIND_NOW flag in the dynamic section indicates immediate binding is not enabled for a given binary. The presence of both an element of type PT_GNU_RELRO in the program header table and of an element with the DT_BIND_NOW tag and the DF_BIND_NOW flag in the dynamic section indicates full RELRO is enabled for a given binary (see Fig. 9 and Fig. 10). 4. And the DF_1_NOW flag for some link editors. \u21a9 {: .fn #fn:4} Heap corruption protection Heap corruption protection protects memory allocated dynamically by performing several checks, such as checks for corrupted links between list elements, invalid pointers, invalid sizes, double/multiple \u201cfrees\u201d of the same memory allocated, and many corner cases of these. These checks are implementation specific, and vary per allocator. ARM Memory Tagging Extension (MTE) , when available, will provide hardware assistance for a probabilistic mitigation to detect memory safety violations by tagging memory allocations, and automatically checking that the correct tag is used on every memory access. Rust\u2019s default allocator has historically been jemalloc , and it has long been the cause of issues and the subject of much discussion[32]\u2013[38]. Consequently, it has been removed as the default allocator in favor of the operating system\u2019s standard C library default allocator 5 since version 1.32.0 (2019-01-17)[39]. fn main() { let mut x = Box::new([0; 1024]); for i in 0..1026 { unsafe { let elem = x.get_unchecked_mut(i); *elem = 0x4141414141414141u64; } } } Fig. 11.\u2003hello-rust-heap program. {: .figure-caption} $ cargo run Compiling hello-rust-heap v0.1.0 (/home/rcvalle/hello-rust-heap) Finished dev [unoptimized + debuginfo] target(s) in 0.25s Running `target/debug/hello-rust-heap` free(): invalid next size (normal) Aborted Fig. 12.\u2003Build and execution of hello-rust-heap with debug assertions enabled. {: .figure-caption} $ cargo run --release Compiling hello-rust-heap v0.1.0 (/home/rcvalle/hello-rust-heap) Finished release [optimized] target(s) in 0.25s Running `target/release/hello-rust-heap` free(): invalid next size (normal) Aborted Fig. 13.\u2003Build and execution of hello-rust-heap with debug assertions disabled. {: .figure-caption} Heap corruption checks are being performed when using the default allocator (i.e., the GNU Allocator) as seen in Fig. 12 and Fig. 13. 5. Linux's standard C library default allocator is the GNU Allocator, which is derived from ptmalloc (pthreads malloc) by Wolfram Gloger, which in turn is derived from dlmalloc (Doug Lea malloc) by Doug Lea. \u21a9 {: .fn #fn:5} Stack smashing protection Stack smashing protection protects programs from stack-based buffer overflows by inserting a random guard value between local variables and the saved return instruction pointer, and checking if this value has changed when returning from a function. This is also known as \u201cStack Protector\u201d or \u201cStack Smashing Protector (SSP)\u201d. The Rust compiler does not support stack smashing protection. However, more comprehensive alternatives to stack smashing protection exist, such as shadow and safe stack (see backward-edge control flow protection). Fig. 14. Cross references to __stack_chk_fail in hello-rust. {: .figure-caption} To check if stack smashing protection is enabled for a given binary, search for cross references to __stack_chk_fail . The only cross references to __stack_chk_fail in hello-rust are from the statically-linked libbacktrace library (see Fig. 14). Forward-edge control flow protection Forward-edge control flow protection protects programs from having its control flow changed/hijacked by performing checks to ensure that destinations of indirect branches are one of their valid destinations in the control flow graph. The comprehensiveness of these checks vary per implementation. This is also known as \u201cforward-edge control flow integrity (CFI)\u201d. Newer processors provide hardware assistance for forward-edge control flow protection, such as ARM Branch Target Identification (BTI), ARM Pointer Authentication, and Intel Indirect Branch Tracking (IBT) as part of Intel Control-flow Enforcement Technology (CET). However, ARM BTI and Intel IBT -based implementations are less comprehensive than software-based implementations such as LLVM ControlFlowIntegrity (CFI) , and the commercially available grsecurity/PaX Reuse Attack Protector (RAP) . The Rust compiler supports forward-edge control flow protection on nightly builds[40]-[41] 6 . $ readelf -s -W target/debug/rust-cfi | grep \"\\.cfi\" 12: 0000000000005170 46 FUNC LOCAL DEFAULT 14 _RNvCsjaOHoaNjor6_8rust_cfi7add_one.cfi 15: 00000000000051a0 16 FUNC LOCAL DEFAULT 14 _RNvCsjaOHoaNjor6_8rust_cfi7add_two.cfi 17: 0000000000005270 396 FUNC LOCAL DEFAULT 14 _RNvCsjaOHoaNjor6_8rust_cfi4main.cfi ... Fig. 15.\u2003Checking if LLVM CFI is enabled for a given binary[41]. The presence of symbols suffixed with \".cfi\" or the __cfi_init symbol (and references to __cfi_check ) indicates that LLVM CFI (i.e., forward-edge control flow protection) is enabled for a given binary. Conversely, the absence of symbols suffixed with \".cfi\" or the __cfi_init symbol (and references to __cfi_check ) indicates that LLVM CFI is not enabled for a given binary (see Fig. 15). 6. It also supports Control Flow Guard (CFG) on Windows (see https://github.com/rust-lang/rust/issues/68793 ). \u21a9 Backward-edge control flow protection Shadow stack protects saved return instruction pointers from being overwritten by storing a copy of them on a separate (shadow) stack, and using these copies as authoritative values when returning from functions. This is also known as \u201cShadowCallStack\u201d and \u201cReturn Flow Guard\u201d, and is considered an implementation of backward-edge control flow protection (or \u201cbackward-edge CFI\u201d). Safe stack protects not only the saved return instruction pointers, but also register spills and some local variables from being overwritten by storing unsafe variables, such as large arrays, on a separate (unsafe) stack, and using these unsafe variables on the separate stack instead. This is also known as \u201cSafeStack\u201d, and is also considered an implementation of backward-edge control flow protection. Both shadow and safe stack are intended to be a more comprehensive alternatives to stack smashing protection as they protect the saved return instruction pointers (and other data in the case of safe stack) from arbitrary writes and non-linear out-of-bounds writes. Newer processors provide hardware assistance for backward-edge control flow protection, such as ARM Pointer Authentication, and Intel Shadow Stack as part of Intel CET. The Rust compiler does not support shadow or safe stack. There is work currently ongoing to add support for the sanitizers[40], which may or may not include support for safe stack 7 . $ readelf -s target/release/hello-rust | grep __safestack_init Fig. 16.\u2003Checking if LLVM SafeStack is enabled for a given binary. {: .figure-caption} The presence of the __safestack_init symbol indicates that LLVM SafeStack is enabled for a given binary. Conversely, the absence of the __safestack_init symbol indicates that LLVM SafeStack is not enabled for a given binary (see Fig. 16). 7. The shadow stack implementation for the AMD64 architecture and equivalent in LLVM was removed due to performance and security issues. \u21a9 {: .fn #fn:7} Appendix As of the latest version of the Linux Standard Base (LSB) Core Specification , the PT_GNU_STACK program header indicates whether the stack should be executable, and the absence of this header indicates that the stack should be executable. However, the Linux kernel currently sets the READ_IMPLIES_EXEC personality upon loading any executable with the PT_GNU_STACK program header and the PF_X flag set or with the absence of this header, resulting in not only the stack, but also all readable virtual memory mappings being executable. An attempt to fix this was made in 2012 (by this author), and another was made in 2020 . The former never landed, and the latter partially fixed it, but introduced other issues\u2014the absence of the PT_GNU_STACK program header still causes not only the stack, but also all readable virtual memory mappings to be executable in some architectures, such as IA-32 and equivalent (or causes the stack to be non-executable in some architectures, such as AMD64 and equivalent, contradicting the LSB). The READ_IMPLIES_EXEC personality needs to be completely separated from the PT_GNU_STACK program header by having a separate option for it (or setarch -X could just be used whenever READ_IMPLIES_EXEC is needed), and the absence of the PT_GNU_STACK program header needs to have more secure defaults (unrelated to READ_IMPLIES_EXEC ). References D. Hosfelt. \u201cFearless security: memory safety.\u201d Mozilla Hacks. https://hacks.mozilla.org/2019/01/fearless-security-memory-safety/ . D. Hosfelt. \u201cFearless security: thread safety.\u201d Mozilla Hacks. https://hacks.mozilla.org/2019/02/fearless-security-thread-safety/ . S. Klabnik and C. Nichols. \u201cWhat Is Ownership?.\u201d The Rust Programming Language. https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html . S. Klabnik and C. Nichols. \u201cReferences and Borrowing.\u201d The Rust Programming Language. https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html . S. Klabnik and C. Nichols. \u201cThe Slice Type.\u201d The Rust Programming Language. https://doc.rust-lang.org/book/ch04-03-slices.html . S. Klabnik and C. Nichols. \u201cUnsafe Rust.\u201d The Rust Programming Language. https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html . S. Davidoff. \u201cHow Rust\u2019s standard library was vulnerable for years and nobody noticed.\u201d Medium. https://medium.com/@shnatsel/how-rusts-standard-library-was-vulnerable-for-years-and-nobody-noticed-aebf0503c3d6 . \u201cImproper restriction of operations within the bounds of a memory buffer (CWE-119).\u201d MITRE CWE List. https://cwe.mitre.org/data/definitions/119.html . \u201cConcurrency issues (CWE-557).\u201d MITRE CWE List. https://cwe.mitre.org/data/definitions/557.html . K. McAllister. \u201cMemory exploit mitigations #15179.\u201d GitHub. https://github.com/rust-lang/rust/issues/15179 . K. McAllister. \u201cRFC: Memory exploit mitigation #145.\u201d GitHub. https://github.com/rust-lang/rfcs/pull/145 . K. McAllister. \u201cRFC: Memory exploit mitigation.\u201d GitHub. https://github.com/kmcallister/rfcs/blob/hardening/active/0000-memory-exploit-mitigation.md . D. Micay. \u201cEnable PIE by default on Linux for full ASLR #16340.\u201d GitHub. https://github.com/rust-lang/rust/pull/16340 . N. Matsakis. \u201cInteger overflow #560.\u201d GitHub. https://github.com/rust-lang/rfcs/pull/560 . G. Lehel and N. Matsakis. \u201cInteger overflow.\u201d GitHub. https://rust-lang.github.io/rfcs/0560-integer-overflow.html . A. Turon. \u201cTracking issue for integer overflow (RFC 560) #22020.\u201d GitHub. https://github.com/rust-lang/rust/issues/22020 . H. Wilson. \u201cMyths and legends about integer overflow in Rust.\u201d Huon on the Internet. http://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/ . B. Anderson. \u201cStabilize -C overflow-checks #1535.\u201d GitHub. https://github.com/rust-lang/rfcs/pull/1535 . B. Anderson. \u201cStable overflow checks.\u201d GitHub. https://github.com/brson/rfcs/blob/overflow/text/0000-stable-overflow-checks.md . N. Froyd. \u201cAdd -C overflow-checks option #40037.\u201d GitHub. https://github.com/rust-lang/rust/pull/40037 . R. \u00c1. de Esp\u00edndola. \u201crustc requires executable stack #798.\u201d GitHub. https://github.com/rust-lang/rust/issues/798 . A. Seipp. \u201cMake sure librustrt.so is linked with a non-executable stack. #1066.\u201d GitHub. https://github.com/rust-lang/rust/pull/1066 . D. Micay. \u201cRust binaries should not have an executable stack #5643.\u201d GitHub. https://github.com/rust-lang/rust/issues/5643 . D. Micay. \u201cMark the assembly object stacks as non-executable #5647.\u201d GitHub. https://github.com/rust-lang/rust/pull/5647 . A. Clark. \u201cExplicitly disable stack execution on linux and bsd #30859.\u201d GitHub. https://github.com/rust-lang/rust/pull/30859 . \u201cReplace stack overflow checking with stack probes #16012.\u201d GitHub. https://github.com/rust-lang/rust/issues/16012 . B. Striegel. \u201cExtend stack probe support to non-tier-1 platforms, and clarify policy for mitigating LLVM-dependent unsafety #43241.\u201d GitHub. https://github.com/rust-lang/rust/issues/43241 . A. Crichton. \u201crustc: Implement stack probes for x86 #42816.\u201d GitHub. https://github.com/rust-lang/rust/pull/42816 . A. Crichton. \u201cAdd __rust_probestack intrinsic #175.\u201d GitHub. https://github.com/rust-lang/compiler-builtins/pull/175 . B. Anderson. \u201cConsider applying -Wl,-z,relro or -Wl,-z,relro,-z,now by default #29877.\u201d GitHub. https://github.com/rust-lang/rust/issues/29877 . J. L\u00f6thberg. \u201cAdd support for full RELRO #43170.\u201d GitHub. https://github.com/rust-lang/rust/pull/43170 . N. Matsakis. \u201cAllocators in Rust.\u201d Baby Steps. http://smallcultfollowing.com/babysteps/blog/2014/11/14/allocators-in-rust/ . A. Crichton. \u201cRFC: Allow changing the default allocator #1183.\u201d GitHub. https://github.com/rust-lang/rfcs/pull/1183 . A. Crichton. \u201cRFC: Swap out jemalloc.\u201d GitHub. https://rust-lang.github.io/rfcs/1183-swap-out-jemalloc.html . A. Crichton. \u201cTracking issue for changing the global, default allocator (RFC 1974) #27389.\u201d GitHub. https://github.com/rust-lang/rust/issues/27389 . S. Fackler. \u201cPrepare global allocators for stabilization #1974.\u201d GitHub. https://github.com/rust-lang/rfcs/pull/1974 . A. Crichton. \u201cRFC: Global allocators.\u201d GitHub. https://rust-lang.github.io/rfcs/1974-global-allocators.html . B. Anderson. \u201cSwitch the default global allocator to System, remove alloc_jemalloc, use jemallocator in rustc #36963.\u201d GitHub. https://github.com/rust-lang/rust/issues/36963 . A. Crichton. \u201cRemove the alloc_jemalloc crate #55238.\u201d GitHub. https://github.com/rust-lang/rust/pull/55238 . R. de C Valle. \u201cTracking Issue for LLVM Control Flow Integrity (CFI) Support for Rust #89653.\u201d GitHub. https://github.com/rust-lang/rust/issues/89653 . \u201cControlFlowIntegrity.\u201d The Rust Unstable Book. https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#controlflowintegrity . {: .references}","title":"Rust exploit mitigations"},{"location":"posts/2020-09-16-rust-exploit-mitigations/#introduction","text":"The Rust programming language provides memory[1] and thread[2] safety guarantees via its ownership[3], references and borrowing[4], and slice types[5] features. However, Unsafe Rust[6] introduces unsafe blocks, unsafe functions and methods, unsafe traits, and new types that are not subject to the borrowing rules. Parts of the Rust standard library are implemented as safe abstractions over unsafe code (and historically have been vulnerable to memory corruption[7]). Furthermore, the Rust code and documentation encourage creating safe abstractions over unsafe code. This can cause a false sense of security if unsafe code is not properly reviewed and tested. Unsafe Rust introduces features that do not provide the same memory and thread safety guarantees. This causes programs or libraries to be susceptible to memory corruption (CWE-119)[8] and concurrency issues (CWE-557)[9]. Modern C and C++ compilers provide exploit mitigations to increase the difficulty to exploit vulnerabilities resulting from these issues. Therefore, the Rust compiler must also support these exploit mitigations in order to mitigate vulnerabilities resulting from the use of Unsafe Rust. This post documents these exploit mitigations and how they apply to Rust. This post does not discuss the effectiveness of these exploit mitigations as they vary greatly depending on several factors besides their design and implementation, but rather describe what they do, so their effectiveness can be understood within a given context.","title":"Introduction"},{"location":"posts/2020-09-16-rust-exploit-mitigations/#exploit-mitigations","text":"This section documents the exploit mitigations applicable to the Rust compiler when building programs for the Linux operating system on the AMD64 architecture and equivalent. 1 All examples in this section were built using the Rust compiler version 1.40.0 (2019-12-19) on Debian testing (Bullseye). The Rust Programming Language currently has no specification. The Rust compiler (i.e., rustc) is the language reference implementation. All references to \u201cthe Rust compiler\u201d in this post refer to the language reference implementation. Table I \\ Summary of exploit mitigations supported by the Rust compiler when building programs for the Linux operating system on the AMD64 architecture and equivalent. {: .table-title} Exploit mitigation Supported and enabled by default Since Position-independent executable Yes 0.12.0 (2014-10-09) Integer overflow checks Yes (enabled when debug assertions are enabled, and disabled when debug assertions are disabled) 1.1.0 (2015-06-25) Non-executable memory regions Yes 1.8.0 (2016-04-14) Stack clashing protection Yes 1.20.0 (2017-08-31) Read-only relocations and immediate binding Yes 1.21.0 (2017-10-12) Heap corruption protection Yes 1.32.0 (2019-01-17) (via operating system default or specified allocator) Stack smashing protection No Forward-edge control flow protection Yes Nightly Backward-edge control flow protection (e.g., shadow and safe stack) No 1. See https://github.com/rust-lang/rust/tree/master/compiler/rustc_target/src/spec for a list of targets and their default options. \u21a9 {: .fn #fn:1}","title":"Exploit mitigations"},{"location":"posts/2020-09-16-rust-exploit-mitigations/#position-independent-executable","text":"Position-independent executable increases the difficulty of the use of code reuse exploitation techniques, such as return-oriented programming (ROP) and variants, by generating position-independent code for the executable, and instructing the dynamic linker to load it similarly to a shared object at a random load address, thus also benefiting from address-space layout randomization (ASLR). This is also referred to as \u201cfull ASLR\u201d. The Rust compiler supports position-independent executable, and enables it by default since version 0.12.0 (2014-10-09)[10]\u2013[13]. $ readelf -h target/release/hello-rust | grep Type: Type: DYN (Shared object file) Fig. 1.\u2003Checking if an executable is a position-independent executable. {: .figure-caption} An executable with an object type of ET_DYN (i.e., shared object) and not ET_EXEC (i.e., executable) is a position-independent executable (see Fig. 1).","title":"Position-independent executable"},{"location":"posts/2020-09-16-rust-exploit-mitigations/#integer-overflow-checks","text":"Integer overflow checks protects programs from undefined and unintended behavior (which may cause vulnerabilities) by checking for results of signed and unsigned integer computations that cannot be represented in their type, resulting in an overflow or wraparound. The Rust compiler supports integer overflow checks, and enables it when debug assertions are enabled since version 1.0.0 (2015-05-15)[14]\u2013[17], but support for it was not completed until version 1.1.0 (2015-06-25)[16]. An option to control integer overflow checks was later stabilized in version 1.17.0 (2017-04-27)[18]\u2013[20]. fn main() { let u: u8 = 255; println!(\"u: {}\", u + 1); } Fig. 2.\u2003hello-rust-integer program. {: .figure-caption} $ cargo run Compiling hello-rust-integer v0.1.0 (/home/rcvalle/hello-rust-integer) Finished dev [unoptimized + debuginfo] target(s) in 0.23s Running `target/debug/hello-rust-integer` thread 'main' panicked at 'attempt to add with overflow', src/main.rs:3:23 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace. Fig. 3.\u2003Build and execution of hello-rust-integer with debug assertions enabled. {: .figure-caption} $ cargo run --release Compiling hello-rust-integer v0.1.0 (/home/rcvalle/hello-rust-integer) Finished release [optimized] target(s) in 0.23s Running `target/release/hello-rust-integer` u: 0 Fig. 4.\u2003Build and execution of hello-rust-integer with debug assertions disabled. {: .figure-caption} Integer overflow checks are enabled when debug assertions are enabled (see Fig. 3), and disabled when debug assertions are disabled (see Fig. 4). To enable integer overflow checks independently, use the option to control integer overflow checks, scoped attributes, or explicit checking methods such as checked_add 2 . It is recommended that explicit wrapping methods such as wrapping_add be used when wrapping semantics are intended, and that explicit checking and wrapping methods always be used when using Unsafe Rust. 2. See https://doc.rust-lang.org/std/primitive.u32.html for more information on the checked, overflowing, saturating, and wrapping methods (using u32 as an example). \u21a9 {: .fn #fn:2}","title":"Integer overflow checks"},{"location":"posts/2020-09-16-rust-exploit-mitigations/#non-executable-memory-regions","text":"Non-executable memory regions increase the difficulty of exploitation by limiting the memory regions that can be used to execute arbitrary code. Most modern processors provide support for the operating system to mark memory regions as non executable, but it was previously emulated by software, such as in grsecurity/PaX's PAGEEXEC and SEGMEXEC , on processors that did not provide support for it. This is also known as \u201cNo Execute (NX) Bit\u201d, \u201cExecute Disable (XD) Bit\u201d, \u201cExecute Never (XN) Bit\u201d, and others. The Rust compiler supports non-executable memory regions, and enables it by default since its initial release, version 0.1 (2012-01-20)[21], [22], but has regressed since then[23]\u2013[25], and enforced by default since version 1.8.0 (2016-04-14)[25]. $ readelf -l target/release/hello-rust | grep -A 1 GNU_STACK GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 0x10 Fig. 5.\u2003Checking if non-executable memory regions are enabled for a given binary. {: .figure-caption} The presence of an element of type PT_GNU_STACK in the program header table with the PF_X (i.e., executable) flag unset indicates non-executable memory regions 3 are enabled for a given binary (see Fig. 5). Conversely, the presence of an element of type PT_GNU_STACK in the program header table with the PF_X flag set or the absence of an element of type PT_GNU_STACK in the program header table indicates non-executable memory regions are not enabled for a given binary. 3. See the Appendix section for more information on why it affects other memory regions besides the stack. \u21a9 {: .fn #fn:3}","title":"Non-executable memory regions"},{"location":"posts/2020-09-16-rust-exploit-mitigations/#stack-clashing-protection","text":"Stack clashing protection protects the stack from overlapping with another memory region\u2014allowing arbitrary data in both to be overwritten using each other\u2014by reading from the stack pages as the stack grows to cause a page fault when attempting to read from the guard page/region. This is also referred to as \u201cstack probes\u201d or \u201cstack probing\u201d. The Rust compiler supports stack clashing protection via stack probing, and enables it by default since version 1.20.0 (2017-08-31)[26]\u2013[29]. Fig. 6. Cross references to __rust_probestack in hello-rust. {: .figure-caption} fn hello() { println!(\"Hello, world!\"); } fn main() { let _: [u64; 1024] = [0; 1024]; hello(); } Fig 7. Modified hello-rust. {: .figure-caption} Fig. 8. Cross references to __rust_probestack in modified hello-rust. {: .figure-caption} To check if stack clashing protection is enabled for a given binary, search for cross references to __rust_probestack . The __rust_probestack is called in the prologue of functions whose stack size is larger than a page size (see Fig. 6), and can be forced for illustration purposes by modifying the hello-rust example as seen in Fig. 7 and Fig. 8.","title":"Stack clashing protection"},{"location":"posts/2020-09-16-rust-exploit-mitigations/#read-only-relocations-and-immediate-binding","text":"Read-only relocations protect segments containing relocations and relocation information (i.e., .init_array , .fini_array , .dynamic , and .got ) from being overwritten by marking these segments read only. This is also referred to as \u201cpartial RELRO\u201d. The Rust compiler supports read-only relocations, and enables it by default since version 1.21.0 (2017-10-12)[30], [31]. $ readelf -l target/release/hello-rust | grep GNU_RELRO GNU_RELRO 0x000000000002ee00 0x000000000002fe00 0x000000000002fe00 Fig. 9.\u2003Checking if read-only relocations is enabled for a given binary. {: .figure-caption} The presence of an element of type PT_GNU_RELRO in the program header table indicates read-only relocations are enabled for a given binary (see Fig. 9). Conversely, the absence of an element of type PT_GNU_RELRO in the program header table indicates read-only relocations are not enabled for a given binary. Immediate binding protects additional segments containing relocations (i.e., .got.plt ) from being overwritten by instructing the dynamic linker to perform all relocations before transferring control to the program during startup, so all segments containing relocations can be marked read only (when combined with read-only relocations). This is also referred to as \u201cfull RELRO\u201d. The Rust compiler supports immediate binding, and enables it by default since version 1.21.0 (2017-10-12)[30], [31]. $ readelf -d target/release/hello-rust | grep BIND_NOW 0x000000000000001e (FLAGS) BIND_NOW Fig. 10.\u2003Checking if immediate binding is enabled for a given binary. {: .figure-caption} The presence of an element with the DT_BIND_NOW tag and the DF_BIND_NOW flag 4 in the dynamic section indicates immediate binding is enabled for a given binary (see Fig. 10). Conversely, the absence of an element with the DT_BIND_NOW tag and the DF_BIND_NOW flag in the dynamic section indicates immediate binding is not enabled for a given binary. The presence of both an element of type PT_GNU_RELRO in the program header table and of an element with the DT_BIND_NOW tag and the DF_BIND_NOW flag in the dynamic section indicates full RELRO is enabled for a given binary (see Fig. 9 and Fig. 10). 4. And the DF_1_NOW flag for some link editors. \u21a9 {: .fn #fn:4}","title":"Read-only relocations and immediate binding"},{"location":"posts/2020-09-16-rust-exploit-mitigations/#heap-corruption-protection","text":"Heap corruption protection protects memory allocated dynamically by performing several checks, such as checks for corrupted links between list elements, invalid pointers, invalid sizes, double/multiple \u201cfrees\u201d of the same memory allocated, and many corner cases of these. These checks are implementation specific, and vary per allocator. ARM Memory Tagging Extension (MTE) , when available, will provide hardware assistance for a probabilistic mitigation to detect memory safety violations by tagging memory allocations, and automatically checking that the correct tag is used on every memory access. Rust\u2019s default allocator has historically been jemalloc , and it has long been the cause of issues and the subject of much discussion[32]\u2013[38]. Consequently, it has been removed as the default allocator in favor of the operating system\u2019s standard C library default allocator 5 since version 1.32.0 (2019-01-17)[39]. fn main() { let mut x = Box::new([0; 1024]); for i in 0..1026 { unsafe { let elem = x.get_unchecked_mut(i); *elem = 0x4141414141414141u64; } } } Fig. 11.\u2003hello-rust-heap program. {: .figure-caption} $ cargo run Compiling hello-rust-heap v0.1.0 (/home/rcvalle/hello-rust-heap) Finished dev [unoptimized + debuginfo] target(s) in 0.25s Running `target/debug/hello-rust-heap` free(): invalid next size (normal) Aborted Fig. 12.\u2003Build and execution of hello-rust-heap with debug assertions enabled. {: .figure-caption} $ cargo run --release Compiling hello-rust-heap v0.1.0 (/home/rcvalle/hello-rust-heap) Finished release [optimized] target(s) in 0.25s Running `target/release/hello-rust-heap` free(): invalid next size (normal) Aborted Fig. 13.\u2003Build and execution of hello-rust-heap with debug assertions disabled. {: .figure-caption} Heap corruption checks are being performed when using the default allocator (i.e., the GNU Allocator) as seen in Fig. 12 and Fig. 13. 5. Linux's standard C library default allocator is the GNU Allocator, which is derived from ptmalloc (pthreads malloc) by Wolfram Gloger, which in turn is derived from dlmalloc (Doug Lea malloc) by Doug Lea. \u21a9 {: .fn #fn:5}","title":"Heap corruption protection"},{"location":"posts/2020-09-16-rust-exploit-mitigations/#stack-smashing-protection","text":"Stack smashing protection protects programs from stack-based buffer overflows by inserting a random guard value between local variables and the saved return instruction pointer, and checking if this value has changed when returning from a function. This is also known as \u201cStack Protector\u201d or \u201cStack Smashing Protector (SSP)\u201d. The Rust compiler does not support stack smashing protection. However, more comprehensive alternatives to stack smashing protection exist, such as shadow and safe stack (see backward-edge control flow protection). Fig. 14. Cross references to __stack_chk_fail in hello-rust. {: .figure-caption} To check if stack smashing protection is enabled for a given binary, search for cross references to __stack_chk_fail . The only cross references to __stack_chk_fail in hello-rust are from the statically-linked libbacktrace library (see Fig. 14).","title":"Stack smashing protection"},{"location":"posts/2020-09-16-rust-exploit-mitigations/#forward-edge-control-flow-protection","text":"Forward-edge control flow protection protects programs from having its control flow changed/hijacked by performing checks to ensure that destinations of indirect branches are one of their valid destinations in the control flow graph. The comprehensiveness of these checks vary per implementation. This is also known as \u201cforward-edge control flow integrity (CFI)\u201d. Newer processors provide hardware assistance for forward-edge control flow protection, such as ARM Branch Target Identification (BTI), ARM Pointer Authentication, and Intel Indirect Branch Tracking (IBT) as part of Intel Control-flow Enforcement Technology (CET). However, ARM BTI and Intel IBT -based implementations are less comprehensive than software-based implementations such as LLVM ControlFlowIntegrity (CFI) , and the commercially available grsecurity/PaX Reuse Attack Protector (RAP) . The Rust compiler supports forward-edge control flow protection on nightly builds[40]-[41] 6 . $ readelf -s -W target/debug/rust-cfi | grep \"\\.cfi\" 12: 0000000000005170 46 FUNC LOCAL DEFAULT 14 _RNvCsjaOHoaNjor6_8rust_cfi7add_one.cfi 15: 00000000000051a0 16 FUNC LOCAL DEFAULT 14 _RNvCsjaOHoaNjor6_8rust_cfi7add_two.cfi 17: 0000000000005270 396 FUNC LOCAL DEFAULT 14 _RNvCsjaOHoaNjor6_8rust_cfi4main.cfi ... Fig. 15.\u2003Checking if LLVM CFI is enabled for a given binary[41]. The presence of symbols suffixed with \".cfi\" or the __cfi_init symbol (and references to __cfi_check ) indicates that LLVM CFI (i.e., forward-edge control flow protection) is enabled for a given binary. Conversely, the absence of symbols suffixed with \".cfi\" or the __cfi_init symbol (and references to __cfi_check ) indicates that LLVM CFI is not enabled for a given binary (see Fig. 15). 6. It also supports Control Flow Guard (CFG) on Windows (see https://github.com/rust-lang/rust/issues/68793 ). \u21a9","title":"Forward-edge control flow protection"},{"location":"posts/2020-09-16-rust-exploit-mitigations/#backward-edge-control-flow-protection","text":"Shadow stack protects saved return instruction pointers from being overwritten by storing a copy of them on a separate (shadow) stack, and using these copies as authoritative values when returning from functions. This is also known as \u201cShadowCallStack\u201d and \u201cReturn Flow Guard\u201d, and is considered an implementation of backward-edge control flow protection (or \u201cbackward-edge CFI\u201d). Safe stack protects not only the saved return instruction pointers, but also register spills and some local variables from being overwritten by storing unsafe variables, such as large arrays, on a separate (unsafe) stack, and using these unsafe variables on the separate stack instead. This is also known as \u201cSafeStack\u201d, and is also considered an implementation of backward-edge control flow protection. Both shadow and safe stack are intended to be a more comprehensive alternatives to stack smashing protection as they protect the saved return instruction pointers (and other data in the case of safe stack) from arbitrary writes and non-linear out-of-bounds writes. Newer processors provide hardware assistance for backward-edge control flow protection, such as ARM Pointer Authentication, and Intel Shadow Stack as part of Intel CET. The Rust compiler does not support shadow or safe stack. There is work currently ongoing to add support for the sanitizers[40], which may or may not include support for safe stack 7 . $ readelf -s target/release/hello-rust | grep __safestack_init Fig. 16.\u2003Checking if LLVM SafeStack is enabled for a given binary. {: .figure-caption} The presence of the __safestack_init symbol indicates that LLVM SafeStack is enabled for a given binary. Conversely, the absence of the __safestack_init symbol indicates that LLVM SafeStack is not enabled for a given binary (see Fig. 16). 7. The shadow stack implementation for the AMD64 architecture and equivalent in LLVM was removed due to performance and security issues. \u21a9 {: .fn #fn:7}","title":"Backward-edge control flow protection"},{"location":"posts/2020-09-16-rust-exploit-mitigations/#appendix","text":"As of the latest version of the Linux Standard Base (LSB) Core Specification , the PT_GNU_STACK program header indicates whether the stack should be executable, and the absence of this header indicates that the stack should be executable. However, the Linux kernel currently sets the READ_IMPLIES_EXEC personality upon loading any executable with the PT_GNU_STACK program header and the PF_X flag set or with the absence of this header, resulting in not only the stack, but also all readable virtual memory mappings being executable. An attempt to fix this was made in 2012 (by this author), and another was made in 2020 . The former never landed, and the latter partially fixed it, but introduced other issues\u2014the absence of the PT_GNU_STACK program header still causes not only the stack, but also all readable virtual memory mappings to be executable in some architectures, such as IA-32 and equivalent (or causes the stack to be non-executable in some architectures, such as AMD64 and equivalent, contradicting the LSB). The READ_IMPLIES_EXEC personality needs to be completely separated from the PT_GNU_STACK program header by having a separate option for it (or setarch -X could just be used whenever READ_IMPLIES_EXEC is needed), and the absence of the PT_GNU_STACK program header needs to have more secure defaults (unrelated to READ_IMPLIES_EXEC ).","title":"Appendix"},{"location":"posts/2020-09-16-rust-exploit-mitigations/#references","text":"D. Hosfelt. \u201cFearless security: memory safety.\u201d Mozilla Hacks. https://hacks.mozilla.org/2019/01/fearless-security-memory-safety/ . D. Hosfelt. \u201cFearless security: thread safety.\u201d Mozilla Hacks. https://hacks.mozilla.org/2019/02/fearless-security-thread-safety/ . S. Klabnik and C. Nichols. \u201cWhat Is Ownership?.\u201d The Rust Programming Language. https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html . S. Klabnik and C. Nichols. \u201cReferences and Borrowing.\u201d The Rust Programming Language. https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html . S. Klabnik and C. Nichols. \u201cThe Slice Type.\u201d The Rust Programming Language. https://doc.rust-lang.org/book/ch04-03-slices.html . S. Klabnik and C. Nichols. \u201cUnsafe Rust.\u201d The Rust Programming Language. https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html . S. Davidoff. \u201cHow Rust\u2019s standard library was vulnerable for years and nobody noticed.\u201d Medium. https://medium.com/@shnatsel/how-rusts-standard-library-was-vulnerable-for-years-and-nobody-noticed-aebf0503c3d6 . \u201cImproper restriction of operations within the bounds of a memory buffer (CWE-119).\u201d MITRE CWE List. https://cwe.mitre.org/data/definitions/119.html . \u201cConcurrency issues (CWE-557).\u201d MITRE CWE List. https://cwe.mitre.org/data/definitions/557.html . K. McAllister. \u201cMemory exploit mitigations #15179.\u201d GitHub. https://github.com/rust-lang/rust/issues/15179 . K. McAllister. \u201cRFC: Memory exploit mitigation #145.\u201d GitHub. https://github.com/rust-lang/rfcs/pull/145 . K. McAllister. \u201cRFC: Memory exploit mitigation.\u201d GitHub. https://github.com/kmcallister/rfcs/blob/hardening/active/0000-memory-exploit-mitigation.md . D. Micay. \u201cEnable PIE by default on Linux for full ASLR #16340.\u201d GitHub. https://github.com/rust-lang/rust/pull/16340 . N. Matsakis. \u201cInteger overflow #560.\u201d GitHub. https://github.com/rust-lang/rfcs/pull/560 . G. Lehel and N. Matsakis. \u201cInteger overflow.\u201d GitHub. https://rust-lang.github.io/rfcs/0560-integer-overflow.html . A. Turon. \u201cTracking issue for integer overflow (RFC 560) #22020.\u201d GitHub. https://github.com/rust-lang/rust/issues/22020 . H. Wilson. \u201cMyths and legends about integer overflow in Rust.\u201d Huon on the Internet. http://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/ . B. Anderson. \u201cStabilize -C overflow-checks #1535.\u201d GitHub. https://github.com/rust-lang/rfcs/pull/1535 . B. Anderson. \u201cStable overflow checks.\u201d GitHub. https://github.com/brson/rfcs/blob/overflow/text/0000-stable-overflow-checks.md . N. Froyd. \u201cAdd -C overflow-checks option #40037.\u201d GitHub. https://github.com/rust-lang/rust/pull/40037 . R. \u00c1. de Esp\u00edndola. \u201crustc requires executable stack #798.\u201d GitHub. https://github.com/rust-lang/rust/issues/798 . A. Seipp. \u201cMake sure librustrt.so is linked with a non-executable stack. #1066.\u201d GitHub. https://github.com/rust-lang/rust/pull/1066 . D. Micay. \u201cRust binaries should not have an executable stack #5643.\u201d GitHub. https://github.com/rust-lang/rust/issues/5643 . D. Micay. \u201cMark the assembly object stacks as non-executable #5647.\u201d GitHub. https://github.com/rust-lang/rust/pull/5647 . A. Clark. \u201cExplicitly disable stack execution on linux and bsd #30859.\u201d GitHub. https://github.com/rust-lang/rust/pull/30859 . \u201cReplace stack overflow checking with stack probes #16012.\u201d GitHub. https://github.com/rust-lang/rust/issues/16012 . B. Striegel. \u201cExtend stack probe support to non-tier-1 platforms, and clarify policy for mitigating LLVM-dependent unsafety #43241.\u201d GitHub. https://github.com/rust-lang/rust/issues/43241 . A. Crichton. \u201crustc: Implement stack probes for x86 #42816.\u201d GitHub. https://github.com/rust-lang/rust/pull/42816 . A. Crichton. \u201cAdd __rust_probestack intrinsic #175.\u201d GitHub. https://github.com/rust-lang/compiler-builtins/pull/175 . B. Anderson. \u201cConsider applying -Wl,-z,relro or -Wl,-z,relro,-z,now by default #29877.\u201d GitHub. https://github.com/rust-lang/rust/issues/29877 . J. L\u00f6thberg. \u201cAdd support for full RELRO #43170.\u201d GitHub. https://github.com/rust-lang/rust/pull/43170 . N. Matsakis. \u201cAllocators in Rust.\u201d Baby Steps. http://smallcultfollowing.com/babysteps/blog/2014/11/14/allocators-in-rust/ . A. Crichton. \u201cRFC: Allow changing the default allocator #1183.\u201d GitHub. https://github.com/rust-lang/rfcs/pull/1183 . A. Crichton. \u201cRFC: Swap out jemalloc.\u201d GitHub. https://rust-lang.github.io/rfcs/1183-swap-out-jemalloc.html . A. Crichton. \u201cTracking issue for changing the global, default allocator (RFC 1974) #27389.\u201d GitHub. https://github.com/rust-lang/rust/issues/27389 . S. Fackler. \u201cPrepare global allocators for stabilization #1974.\u201d GitHub. https://github.com/rust-lang/rfcs/pull/1974 . A. Crichton. \u201cRFC: Global allocators.\u201d GitHub. https://rust-lang.github.io/rfcs/1974-global-allocators.html . B. Anderson. \u201cSwitch the default global allocator to System, remove alloc_jemalloc, use jemallocator in rustc #36963.\u201d GitHub. https://github.com/rust-lang/rust/issues/36963 . A. Crichton. \u201cRemove the alloc_jemalloc crate #55238.\u201d GitHub. https://github.com/rust-lang/rust/pull/55238 . R. de C Valle. \u201cTracking Issue for LLVM Control Flow Integrity (CFI) Support for Rust #89653.\u201d GitHub. https://github.com/rust-lang/rust/issues/89653 . \u201cControlFlowIntegrity.\u201d The Rust Unstable Book. https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#controlflowintegrity . {: .references}","title":"References"}]}